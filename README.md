# iOSEncrypt-Hash
iOS散列加密解密相关
# iOS散列和加密算法
安全性对于一个app来说是极为重要的，比如说当一个app服务端使用明文进行密码存储的时候，一旦用户密码泄露，对于用户来说影响是极其大的，可能用户的这个密码在前提的平台也在使用。所以在开发中我们需要对一些重要的信息比如用户隐私进行加密。

##总的来说，在安全性上，我们可以从几个方面入手：
1. app代码层面上的安全。
    *  比如说代码混淆，代码加密或者加壳，增加被逆向的难度。
2. 网络传输前后的安全
    *  尽量使用https而不是http。
    *  无论是get还是post请求，可以理解为都是在明文传输。所以请求和响应都可以进行加密和签名处理。
3. 数据存储的安全。
   *  密码或者其他重要信息不要在服务端或者app内明文存储，而应该是使用这些信息的哈希值或者加密哈希值后再进行存储。

##几种常见的散列和加密算法
###一. 哈希(散列)算法
*     散列就是对数据信息的摘要，提炼。
*     散列结果不可逆，这保证了无法通过散列的结果推导出原文。
*     无论是什么数据，散列后的结果长度是一样的，比如MD5运算后得到的都是128bit。
*     对于相同的数据散列后的结果是一样的,这保证了“唯一性”。
*     对于不同的数据散列后的结果是不同的。存在相同的可能性，但概率不大,因为数据是有无限的，而散列结果长度是固定的，这样导致肯定会存在不同数据对应同样散列结果的可能,但基本可以忽略不计。
*     数据随便一点点的改动，散列的结果变化会很大。

所以散列可以用来做数据签名，或者说唯一性的标识。
1. MD5
Message Digest Algorithm MD5（中文名为消息摘要算法第五版）
输出：128bit。
因为MD5已经被破解，所以不再推荐在重要场合使用。而且已经存在对MD5进行穷举的[网站](https://www.cmd5.com/)。

*加盐：*就是在原信息的基础上，加入一段字符串，再进行散列运算。
这样的做法，可以在原来简单MD5的基础上，加大一些被穷举出原文的难度。所以相对直接MD5,安全性会稍微高一点点。
但是也会存在问题，一旦盐泄漏，也就是加入的那段字符串泄漏，穷举出来的可能性就会变大。
苹果本身也不推荐我们再使用md5了，推荐我们去使用SHA256或者强度更高的。
![Snip20200414_21](media/15868313128709/Snip20200414_21.png)

2. SHA1/256/512
   SHA1:  安全哈希算法（Secure Hash Algorithm）
   输出： 160bit
   SHA256:
   输出：256bit
   SHA512:
   输出：512bit
3. HMac
HMac和MD5非常相似的，只不过在MD5的基础上，多了盐。
可以理解成：本来加盐md5(message + salt)这个操作盐是固定写死在本地的，而HMAC中salt是动态从服务端获取的，然后再进行两次散列。这样黑客就不容易猜出salt，也增加了破解原文的难度。

> Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用HMAC替代我们自己的salt算法，可以使程序算法更标准化，也更安全。

用途：
*     消息摘要
      有些地方是不能进行明文存储的，比如用户密码等，这时候就可以使用密码的哈希值或者加密哈希值后再去进行存储。
*     数字签名
      比如在在通信请求中，我们对请求和响应数据进行散列得到散列信息，然后使用RSA进行散列信息的加密。因为秘钥只有服务端有，服务端拿到RSA加密的散列信息后验签，就能知道数据是否完整，有没有被篡改过等等。
*     查找
      因为哈希的“唯一性”，所以可以拿来当做数据的身份证，指纹。比如通过直接对比两个文件的哈希值，就可以知道这两个文件是不是同一个文件。
*     版权
      也是因为“唯一性”，比如你发布了个视频或者文章，别人拿了你的视频文章也去发布，这里就会有盗版的问题，怎么区分正版，就是通过哈希，你先发布的，所以系统会记录你之前发布的视频哈希值，一比较如果两哈希值一样，说明后者存在盗版的问题。
    

###二. 对称加密
对称加密只有一个秘钥，明文通过秘钥加密获得密文;密文通过秘钥解密获得明文。
    1. DES
        数据加密标准，现在用的很少了，加密强度不够。
    2. 3DES
        使用3个秘钥，对数据进行3次加密，强度增加了，但秘钥的存储难度大大加大了。
    3. AES
       高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。
    优点：加密解密速度快，适用于数据量大的场景。
    缺点：秘钥的传输与存储，一旦秘钥泄漏，加密也就暴露了。
    所以一般秘钥用RSA来加密传输。比如iOS中钥匙串的访问就是AES。
    AES的话有五种加密模式
    1.电码本模式（Electronic Codebook Book (ECB)
    2.密码分组链接模式（Cipher Block Chaining (CBC)）
    3.计算器模式（Counter (CTR)）
    4.密码反馈模式（Cipher FeedBack (CFB)）
    5.输出反馈模式（Output FeedBack (OFB)）
    常用的是：
    电话本模式(ECB)
        会把数据分成几块，每一块独立加密。
        比如说我改了第三块的一点点数据，那么ECB加密模式下，修改前前面两块的加密结果和修改后前面两块的加密结果是一样的。只有第三块因为数据的修改导致加密的不同。
    密码分组链接模式(CBC)
        同样会把数据分成几块，但每块存在依赖关系，比如第二块的加密依赖于第一块数据，第三块依赖于第二块；
        解密也存在依赖关系，第二块解密依赖于第一块数据，第三块依赖于第二块。
        这样的做法，保证了数据的完整性，只要一块有问题，那么就说明数据被篡改过。
    
    
###三. 非对称加密
RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。
    RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密公钥，只要两个质数足够大，破解的可能性就足够小。至少在现阶段是没可能因式分解出来的。所以RSA私钥一般是1024位，在重要场合可能是2048位。
    非对称加密，公钥加密，私钥解密，速度相对较慢，适用于数据量小的场景。
    比如说支付宝，使用AES对请求和响应内容进行加密，防止内容的泄漏。使用RSA进行加密内容的签名，两端分别加签验签，防止数据的篡改。
 RSA具体实现原理可以看一下这个博客:[RSA算法原理一](https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)，[RSA算法原理二](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)
 





